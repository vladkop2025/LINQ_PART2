using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using static LINQ_PART2.Program;

namespace LINQ_PART2
{
    class Program
    {
        static void Main(string[] args)
        {
            /*Профессия C#-разработчик Язык C# Модуль 15.Основы LINQ.Часть 2 
            6/8   15.5. Отложенное и немедленное выполнение LINQ

            Для того чтобы эффективно пользоваться LINQ, стоит вникнуть, как он себя ведёт «под капотом», то есть как именно происходит выполнение его методов.

            Происходит это либо отложено, либо немедленно.

            *************************
            Отложенное выполнение
            *************************
            
                При отложенном выполнении выражение не будет выполнено, пока мы не обратимся к его результату в цикле или итерации.

            В качестве примера возьмём уже знакомую вам выборку из списка студентов:

                        var students = new List<Student>
            {
             new Student {Name="Андрей", Age=23 },
             new Student {Name="Сергей", Age=27 },
             new Student {Name="Дмитрий", Age=29 }
            };

            var youngStudents = from s in students where s.Age < 25 select s;
            //Запрос, написанный выше, будет выполнен, лишь когда мы обратимся к результатам нашей выборки, например в цикле: 

             foreach (var stud in youngStudents)
                Console.WriteLine(stud.Name);

            Вывод: Андрей

            Стадии выполнения LINQ-запроса можно условно разделить так:

               - Получение источника данных (инициализация коллекции, в нашем случае списка студентов).
               - Создание запроса (определение переменной youngStudents).
               - Выполнение и получение результата (при обращении к переменной в цикле).

            После того как запрос определён, при необходимости он может выполняться несколько раз.

            Источник данных (здесь — список студентов) до выполнения запроса может менять несколько раз. Это можно наглядно увидеть, если попробовать 
            изменить какой-либо из элементов до обращения к выборке: 

            var students = new List<Student>
            {
                new Student {Name="Андрей", Age=23 },
                new Student {Name="Сергей", Age=27 },
                new Student {Name="Дмитрий", Age=29 }
            };

            var youngStudents = from s in students where s.Age < 25 select s;

            // Добавим нового студента уже после инициализанции LINQ-запроса
            students.Add(new Student { Name = "Анна", Age = 21 });

            Вывод: Андрей
                   Анна

            Если бы запрос тут выполнился сразу после инициализации, новый студент бы в выборку не попал.

            Знание этого принципа особенно помогает при проектировании кода, производящего выборку объектов из БД через Entity Framework 
            (который мы также изучим в этом курсе), так как мы знаем, что запрос к базе пойдет именно тогда, когда мы обратимся к выборке.

            Важно зафиксировать, что сама переменная запроса — youngStudents — не выполняет никаких действий. Она просто хранит сам запрос.

            *************************
            Немедленное выполнение
            *************************
            
            Некоторые методы всё же позволяют нам запустить выполнение запроса мгновенно.

            Например, это методы, которые возвращают из коллекции один элемент или одно какое-либо значение: 

                Count();
                Average();
                First() / FirstOrDefault();
                Min();
                Max().
            
            В принципе такое поведение логично, так как, чтобы получить из последовательности одно значение, удовлетворяющее определенным условиям, 
            нужно сначала получить все элементы и пройтись по ним циклом  foreach

            // здесь запрос будет выполнен немедленно, и в переменную будет сохранено количество элементов выборки
            
                var youngStudents = (from s in students where s.Age < 25 select s).Count();

            Ещё один способ запустить мгновенное выполнение LINQ-выражения — сохранить результат выборки в новую коллекцию с помощью таких методов, как:

                ToArray();
                ToList();
                ToHashSet() и т.д.

            Например: 

                var youngStudents = students
                    .Where(s => s.Age < 25) // на этом этапе происходит генерация LINQ-выражения
                    .ToList(); // А вот тут уже будет выполнение

            */


        }
        // Класс Student, который нужно добавить
        class Student
        {
            public string Name { get; set; }
            public int Age { get; set; }
        }
    }    
}

/*
Задание 15.5.1
В каком случае происходит отложенное выполнение LINQ-команд?

При вызове FirstOrDefault()
При вызове метода Any()
При вызове метода ToList()
При вызове ToHashSet()          X

Ответ: здесь перечислены все методы, вызывающие МГНОВЕННОЕ выполнение LINQ-команд.


Задание 15.5.2
Мы хотим получить данные по определенным критериям, для выборки объектов используем LINQ, но не все критерии выборки нам известны сразу.

Как нам следует поступить?
выполнить запрос мгновенно, вызвав после LINQ-запроса ToList(), потом при необходимости выполнить дополнительную фильтрацию
использовать отложенное выполнение, вызвать ToList() в конце или просто перебрать в цикле foreach                               X
без разницы
нет верного ответа

Ответ: так мы избежим ненужных данных в выборке и сэкономим ресурсы.


Задание 15.5.3
Будут ли следующие LINQ-команды выполнены отложено или немедленно?

var result = numbers.Where(n => n < 5); Отложено 
Ответ: так как здесь метод возвращает IEnumerable<int>, и запрос будет выполнен только в цикле foreach, либо перед сохранением в другую коллекцию.

var result2 = numbers.All(n => n > 5);  Немедленно
Ответ: так как тут метод должен вернуть логическое значение, которое нужно вычислить сразу.

var result3 = numbers.Where(n => n == 0).ToArray(); Немедленно
Ответ: так как тут результат выборки мы должны сохранить в новую коллекцию, соответственно, перед этим его нужно вычислить.

var result4 = employees.Where(e => e.Name.Contains("F"));   Отложено
Ответ: так как здесь метод возвращает IEnumerable<T>, и запрос будет выполнен только в цикле foreach, либо перед сохранением в другую коллекцию.

var result5 = employees.Distinct(); Отложено
Ответ: так как здесь метод возвращает IEnumerable<T>, и запрос будет выполнен только в цикле foreach, либо перед сохранением в другую коллекцию.

var result6 = letters.Zip(numbers, (l, n) => l + n.ToString()); Отложено
Ответ: так как здесь метод возвращает IEnumerable<string>, и запрос будет выполнен только в цикле foreach, либо перед сохранением в другую коллекцию.


Задание 15.5.4
Напишите свой пример, который позволит узнать, приводит ли метод ToArray() к мгновенному выполнению LINQ-запроса?

Подсказка
Возьмите тестовую коллекцию строк или чисел.

Попробуйте выполнить обычный отложенный LINQ-запрос с выборкой по каким-либо условиям, затем измените коллекцию так, чтобы это повлияло на результат, и ниже выведите результат в консоль. 

Затем сделайте то же самое, добавив в конце LINQ-выражения .ToArray() и посмотрите, изменится ли что-либо.

//  Подготовим тестовые данные
var names = new List<string>() { "Вася", "Вова", "Петя", "Андрей"};
 
// Подготовим тестовую выборку (без ToArray())
var experiment = names.Where(name => name.StartsWith("В"));
 
// уберем несколько элементов уже после выборки (если она выполняется отложено, то они в неё не попадут)
   names.Remove("Вася");
   names.Remove("Вова");
 
// обратимся к выборке в цикле foreach
foreach (var word in experiment)
   Console.WriteLine(word);

Убедимся, что выборка пустая (это значит, что выражение выполнялось отложено (мы успели убрать элементы уже после декларации LINQ-выражения, и они не попали в выборку)).

Теперь эксперимент с ToArray():

//  Снова возьмем те же тестовые данные
var names = new List<string>() { "Вася", "Вова", "Петя", "Андрей"};
 
// Теперь добавим ToArray() в конце того же самого LINQ-запроса
var experiment = names.Where(name => name.StartsWith("В")).ToArray();
 
// Также уберем несколько элементов
   names.Remove("Вася");
   names.Remove("Вова");
 
// обратимся к выборку в цикле foreach
foreach (var word in experiment)
   Console.WriteLine(word);

Теперь мы видим слова в выборке, а это значит, что LINQ-запрос выполнился мгновенно, и то, что мы убрали элементы в строчке ниже, на результат уже не повлияло.
*/
